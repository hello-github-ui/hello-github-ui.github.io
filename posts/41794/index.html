<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Socket编程学习(一) | Lorem MoonのStory</title><meta name="keywords" content="Java,Socket,网络编程"><meta name="author" content="Lorem Moon"><meta name="copyright" content="Lorem Moon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Socket 编程学习篇    一、概念TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中（四层模型从下到上分别是：物理层&#x2F;数据链路层、网络层&#x2F;IP层、传输层TCP&#x2F;UDP、应用层HTTP&#x2F;FTP等），它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 另一个重要的">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket编程学习(一)">
<meta property="og:url" content="https://hello-github-ui.github.io/posts/41794/index.html">
<meta property="og:site_name" content="Lorem MoonのStory">
<meta property="og:description" content="Socket 编程学习篇    一、概念TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中（四层模型从下到上分别是：物理层&#x2F;数据链路层、网络层&#x2F;IP层、传输层TCP&#x2F;UDP、应用层HTTP&#x2F;FTP等），它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 另一个重要的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.imgdb.cn/item/618930862ab3f51d91b34c10.jpg">
<meta property="article:published_time" content="2021-11-08T14:03:16.000Z">
<meta property="article:modified_time" content="2022-10-22T06:47:40.080Z">
<meta property="article:author" content="Lorem Moon">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Socket">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/618930862ab3f51d91b34c10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hello-github-ui.github.io/posts/41794/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"D5QZVMNT9K","apiKey":"92de0b03da46fa778c95817524081160","indexName":"hexo-blog","hits":{"per_page":100},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Socket编程学习(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-10-22 14:47:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/6159d89b2ab3f51d91b0e8d0.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">60</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">46</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/musics/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/618930862ab3f51d91b34c10.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lorem MoonのStory</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/musics/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Socket编程学习(一)<a class="post-edit-link" href="https://github.com/hello-github-ui/hexo-blog-source/tree/master/source/_posts/Socket编程学习-一.md" title="Edited on" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-08T14:03:16.000Z" title="Created 2021-11-08 22:03:16">2021-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-10-22T06:47:40.080Z" title="Updated 2022-10-22 14:47:40">2022-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code/">code</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>15min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Socket编程学习(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>Socket 编程学习篇</p>
</blockquote>
<hr/>

<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中（四层模型从下到上分别是：物理层/数据链路层、网络层/IP层、传输层TCP/UDP、应用层HTTP/FTP等），它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。<br>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（ MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>
<h3 id="JAVA-Socket"><a href="#JAVA-Socket" class="headerlink" title="JAVA Socket"></a>JAVA Socket</h3><p>所谓socket 通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>
<p>Socket和ServerSocket类库位于java.net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。</p>
<h3 id="重要的Socket-API"><a href="#重要的Socket-API" class="headerlink" title="重要的Socket API"></a>重要的Socket API</h3><p>java.net.Socket继承于java.lang.Object，有八个构造器，其方法并不多，下面介绍使用最频繁的三个方法，其它方法大家可以见JDK-1.3文档。</p>
<p>Accept方法用于产生”阻塞”，直到接受到一个连接，并且返回一个客户端的Socket对象实例。”阻塞”是一个术语，它使程序运行暂时”停留”在这个地方，直到一个会话产生，然后程序继续；通常”阻塞”是由循环产生的。<br>getInputStream方法获得网络连接输入，同时返回一个InputStream对象实例。<br>getOutputStream方法连接的另一端将得到输入，同时返回一个OutputStream对象实例。<br>注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><blockquote>
<p>socket通信时，都是必须先启动服务端，再启动客户端才能建立连接实现通信的</p>
</blockquote>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考文章：https://www.codenong.com/cs106175296/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 030</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 15:34 2021/11/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TCP通信的客户端：向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据</span></span><br><span class="line"><span class="comment"> * 表示客户端的类：</span></span><br><span class="line"><span class="comment"> * java.net.Socket：此类实现客户端套接字（也可以叫做“套接字”）。套接字是两台机器之间通信的端点。</span></span><br><span class="line"><span class="comment"> * 套接字：包含了IP地址和端口号的网络单位</span></span><br><span class="line"><span class="comment"> * 构造方法：</span></span><br><span class="line"><span class="comment"> * Socket(String host, int port) 创建一个流套接字并将其连接到指定主机上的指定端口号</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * String host：服务器主机的名称/服务器的ip地址</span></span><br><span class="line"><span class="comment"> * int port：服务器的端口号</span></span><br><span class="line"><span class="comment"> * 成员方法：</span></span><br><span class="line"><span class="comment"> * OutputStream getOutputStream() 返回此套接字的输出流</span></span><br><span class="line"><span class="comment"> * InputStream getInputStream() 返回此套接字的输入流</span></span><br><span class="line"><span class="comment"> * void close() 关闭此套接字</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现步骤：</span></span><br><span class="line"><span class="comment"> * 1. 创建一个客户端对象 Socket，构造方法绑定服务器的IP地址和端口号</span></span><br><span class="line"><span class="comment"> * 2. 使用 Socket 对象中的方法 getOutputStream() 获取网络字节输出流 OutputStream对象</span></span><br><span class="line"><span class="comment"> * 3. 使用网络字节输出流 OutputStream 对象中的方法 write，给服务器发送数据</span></span><br><span class="line"><span class="comment"> * 4. 使用 Socket 对象中的方法 getInputStream() 获取网络字节输入流 InputStream对象</span></span><br><span class="line"><span class="comment"> * 5. 使用网络字节输入流 InputStream对象中的方法 read，读取服务器返回的数据。</span></span><br><span class="line"><span class="comment"> * 6. 释放资源（Socket）</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1. 客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象</span></span><br><span class="line"><span class="comment"> * 2. 当我们创建客户端对象Socket的时候，就会去请求服务器，并与服务器经过3次握手建立链接通路</span></span><br><span class="line"><span class="comment"> * 这时如果服务器没有启动，那么就会抛出异常</span></span><br><span class="line"><span class="comment"> * 如果服务器已经启动，那么就可以进行交互了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</span></span><br><span class="line">        String message = <span class="string">&quot;你好服务器，我是客户端&quot;</span>;</span><br><span class="line">        os.write(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*********解决bug：服务端读取不到 len = -1 标识，会一直处在死循环等待状态ing**********/</span></span><br><span class="line">        <span class="comment">//通过shutdownOutput高速服务器已经发送完数据，后续只能接受数据</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用Socket对象中的方法getInputStream获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">int</span> len; <span class="comment">// 基本数据类型在方法内部（局部变量）时，可以省略初始化，会默认初始化的；但是作为成员变量时则不可以</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 用于记录 服务端回写 的数据</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 注意：多线程时要使用 StringBuffer</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 5. 使用网络字节输入流InputStream对象中的方法read，读取服务器返回的数据。</span></span><br><span class="line">            <span class="comment">// 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len, StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印输出一下服务端回写的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get message from server: &quot;</span> + sb);</span><br><span class="line">        <span class="comment">// 6. 释放资源（Socket）</span></span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考文章：https://www.codenong.com/cs106175296/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 030</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 20:10 2021/11/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TCP通信的服务器端：接收客户端的请求，读取客户端发送的数据，给客户端回写数据</span></span><br><span class="line"><span class="comment"> * 表示服务器的类：</span></span><br><span class="line"><span class="comment"> * java.net.ServerSocket：此类实现服务器套接字</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 构造方法：</span></span><br><span class="line"><span class="comment"> * ServerSocket(int port) 创建绑定到特定端口的服务器套接字</span></span><br><span class="line"><span class="comment"> * 服务器端必须明确一件事，必须得知道是哪个客户端请求的服务器</span></span><br><span class="line"><span class="comment"> * 所以可以使用 accept() 方法获取到请求的客户端对象 Socket</span></span><br><span class="line"><span class="comment"> * 成员方法：</span></span><br><span class="line"><span class="comment"> * Socket accept() 侦听并接受到此套接字的连接</span></span><br><span class="line"><span class="comment"> * 服务器的实现步骤：</span></span><br><span class="line"><span class="comment"> * 1. 创建服务器 ServerSocket 对象和系统要指定的端口号</span></span><br><span class="line"><span class="comment"> * 2. 使用 ServerSocket 对象中的方法 accept， 获取到请求的客户端对象 Socket</span></span><br><span class="line"><span class="comment"> * 3. 使用Socket对象中的方法 getInputStream() 获取网络字节输入流 InputStream对象</span></span><br><span class="line"><span class="comment"> * 4. 使用网络字节输入流 InputStream 对象中的方法 read，读取客户端发送的数据</span></span><br><span class="line"><span class="comment"> * 5. 使用 Socket 对象中的方法 getOutputStream() 获取网络字节输出流OutputStream对象</span></span><br><span class="line"><span class="comment"> * 6. 使用网络字节输出流 OutputStream 对象中的方法 write，给客户端回写数据</span></span><br><span class="line"><span class="comment"> * 7. 释放资源（Socket， ServerSocket）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*一定要先启动 服务端，再启动 客户端才能执行*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建服务器 ServerSocket 对象和系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 使用 ServerSocket 对象中的方法 accept， 获取到请求的客户端对象 Socket</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 3. 使用Socket对象中的方法 getInputStream() 获取网络字节输入流 InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 多线程下注意异常</span></span><br><span class="line">        <span class="comment">// 只有当客户端关闭它的输出流的时候，服务端才能取得结尾的-1</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 4. 使用网络字节输入流 InputStream 对象中的方法 read，读取客户端发送的数据</span></span><br><span class="line">            <span class="comment">// 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len, StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印输出 客户端发送的消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get message from client: &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 使用 Socket 对象中的方法 getOutputStream() 获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 6. 使用网络字节输出流 OutputStream 对象中的方法 write，给客户端回写数据</span></span><br><span class="line">        os.write(<span class="string">&quot;Hello Client,I get the message...&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//  7. 释放资源（Socket， ServerSocket）</span></span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="如何告知服务端已经发送完信息"><a href="#如何告知服务端已经发送完信息" class="headerlink" title="如何告知服务端已经发送完信息"></a>如何告知服务端已经发送完信息</h3><p>其实这个问题还是比较重要的，正常来说，客户端打开一个输出流，如果不做约定，也不关闭它，那么服务端永远不知道客户端是否发送完消息，那么服务端会一直等待下去，直到读取超时。所以怎么告知服务端已经发送完消息就显得特别重要。</p>
<h4 id="1、通过Socket关闭"><a href="#1、通过Socket关闭" class="headerlink" title="1、通过Socket关闭"></a>1、通过Socket关闭</h4><p>可以在客户端发送完消息后，采取手动关闭Socket的方式，服务端就会收到相应的关闭信号，那么服务端也就知道<code>网络字节流</code>已经关闭了，这个时候读取操作完成，就可以继续后续的工作了。</p>
<blockquote>
<p>但是这种方式有一些缺点：客户端Socket关闭后，将不能再接收服务端发送的消息，也不能再向服务端发送消息了。如果客户端想再次发送消息，需要重新创建Socket连接</p>
</blockquote>
<h4 id="2、通过Socket关闭输出流的方式"><a href="#2、通过Socket关闭输出流的方式" class="headerlink" title="2、通过Socket关闭输出流的方式"></a>2、通过Socket关闭输出流的方式</h4><p>这种方式就是上面客户端代码中采用的方式，在发送完消息后，直接调用 <code>socket.shutdownOutput()</code>方法，底层会告知服务端我这边已经写完了，那么服务端收到消息后，就能知道已经取完消息了，如果服务端有要返回给客户的消息，那么就可以通过服务端的输出流发送给客户端，如果没有，直接关闭Socket对象就可以了。</p>
<blockquote>
<p>这种方式通过关闭客户端的输出流，告知服务端已经写完了，虽然可以读到服务端发送的消息，但是还是有一点点缺点：不能再次发送消息给服务端，如果再次发送，需要重新建立Socket连接。这个缺点，在访问频率比较高的情况下将是一个需要优化的地方。</p>
</blockquote>
<h4 id="3、通过约定符号"><a href="#3、通过约定符号" class="headerlink" title="3、通过约定符号"></a>3、通过约定符号</h4><p>这种方式的用法，就是双方约定一个字符或者一个短语，来当做消息发送完成的标识，通常这么做就需要改造读取方法。假如约定单端的一行为end，代表发送完成，例如下面的消息，end则代表消息发送完成：<br>    hello abc<br>end<br>那么服务端响应的读取操作需要进行如下改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = server.accept();</span><br><span class="line"><span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">BufferedReader read=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(),“UTF-<span class="number">8</span>”));</span><br><span class="line">String line;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> ((line = read.readLine()) != <span class="keyword">null</span> &amp;&amp; “end”.equals(line)) &#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    sb.append(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见，服务端不仅判断是否读到了流的末尾，还判断了是否读到了约定的末尾。</p>
<blockquote>
<p>这么做的优缺点如下：<br>优点：不需要关闭流，当发送完一条命令（消息）后可以再次发送新的命令（消息）<br>缺点：需要额外的约定结束标志，太简单的容易出现在要发送的消息中，误被结束，太复杂的不好处理，还占带宽。<br>经过了这么多的优化还是有缺点，难道就没有完美的解决方案吗，答案是有的，看接下来的内容。</p>
</blockquote>
<h4 id="4、通过指定长度"><a href="#4、通过指定长度" class="headerlink" title="4、通过指定长度"></a>4、通过指定长度</h4><p>如果你了解一点class文件的结构（后续会写，敬请期待），那么你就会佩服这么设计方式，也就是说我们可以在此找灵感，就是我们可以先指定后续命令的长度，然后读取指定长度的内容做为客户端发送的消息。</p>
<p>如果你了解一点class文件的结构（后续会写，敬请期待），那么你就会佩服这么设计方式，也就是说我们可以在此找灵感，就是我们可以先指定后续命令的长度，然后读取指定长度的内容做为客户端发送的消息。</p>
<blockquote>
<p>现在首要的问题就是用几个字节指定长度呢，我们可以算一算：<br>1个字节：最大256，表示256B<br>2个字节：最大65536，表示64K<br>3个字节：最大16777216，表示16M<br>4个字节：最大4294967296，表示4G</p>
</blockquote>
<p>依次类推，这个时候是不是很纠结，最大的当然是最保险的，但是真的有必要选择最大的吗，其实如果你稍微了解一点UTF-8的编码方式（字符编码后续会写，敬请期待），那么你就应该能想到为什么一定要固定表示长度字节的长度呢，我们可以使用变长方式来表示长度的表示，比如：第一个字节首位为0：即0XXXXXXX，表示长度就一个字节，最大128，表示128B<br>第一个字节首位为110，那么附带后面一个字节表示长度：即110XXXXX 10XXXXXX，最大2048，表示2K<br>第一个字节首位为1110，那么附带后面二个字节表示长度：即110XXXXX 10XXXXXX 10XXXXXX，最大131072，表示128K。<br>依次类推，上面提到的这种用法适合高富帅的程序员使用，一般呢，如果用作命名发送，两个字节就够了，如果还不放心4个字节基本就能满足你的所有要求，下面的例子我们将采用2个字节表示长度，目的只是给你一种思路，让你知道有这种方式来获取消息的结尾。</p>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket.type04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 030</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 0:51 2021/11/9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 如何告知服务端已经发送完信息</span></span><br><span class="line"><span class="comment"> *  实现方式第四种：4、通过指定长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server将一直等待连接的到来&quot;</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="comment">// 因为可以复用Socket且能判断长度，所以可以一个Socket用到底</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先读取两个字节表示的长度</span></span><br><span class="line">            <span class="keyword">int</span> first = is.read();</span><br><span class="line">            <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">            <span class="keyword">if</span> (first == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> second = is.read();</span><br><span class="line">            <span class="keyword">int</span> length = (first &lt;&lt; <span class="number">8</span>) + second;</span><br><span class="line">            <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">            bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">            is.read(bytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;get message from client: &quot;</span> + <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket.type04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 030</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 0:52 2021/11/9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 如何告知服务端已经发送完信息</span></span><br><span class="line"><span class="comment"> *  实现方式第四种：4、通过指定长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 要连接的服务端IP地址和端口</span></span><br><span class="line">        String host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        String message = <span class="string">&quot;你好服务端&quot;</span>;</span><br><span class="line">        <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] sendBytes = message.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">        os.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        os.write(sendBytes.length);</span><br><span class="line">        <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">        os.write(sendBytes);</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">//==========此处重复发送一次，实际项目中为多个命名，此处只为展示用法</span></span><br><span class="line">        message = <span class="string">&quot;第二条消息|&quot;</span>;</span><br><span class="line">        sendBytes = message.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        os.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        os.write(sendBytes.length);</span><br><span class="line">        os.write(sendBytes);</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">//==========此处重复发送一次，实际项目中为多个命名，此处只为展示用法</span></span><br><span class="line">        message = <span class="string">&quot;the third message !&quot;</span>;</span><br><span class="line">        sendBytes = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        os.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        os.write(sendBytes.length);</span><br><span class="line">        os.write(sendBytes);</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端要多做的是，在发送消息之前先把消息的长度发送过去。这种事先约定好长度的做法解决了之前提到的种种问题，<code>Redis</code>的Java客户端<code>Jedis</code>就是用这种方式实现的。当然如果是需要服务器返回结果，那么也依然使用这种方式。服务端也是先发送结果的长度，然后客户端进行读取。当然现在流行的是，长度+类型+数据模式的传输方式。</p>
</blockquote>
<blockquote>
<p>本节内容参考于<a target="_blank" rel="noopener" href="https://www.codenong.com/cs106175296/">码农家园</a>，在此致谢~~~<br>本节示例<a target="_blank" rel="noopener" href="https://github.com/hello-github-ui/java_base/tree/master/net/src/main/java/socket/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%BC%8F">代码仓库</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lorem Moon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://hello-github-ui.github.io/posts/41794/">https://hello-github-ui.github.io/posts/41794/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Socket/">Socket</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/618930862ab3f51d91b34c10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/25574/" title="Socket编程学习(二)"><img class="cover" src="https://pic.imgdb.cn/item/618959cf2ab3f51d91e843c4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-09</div><div class="title">Socket编程学习(二)</div></div></a></div><div><a href="/posts/49125/" title="BIO-NIO-AIO"><img class="cover" src="https://pic.imgdb.cn/item/60d18f04844ef46bb2bcb39a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-22</div><div class="title">BIO-NIO-AIO</div></div></a></div><div><a href="/posts/32282/" title="Difference between FileReader vs FileInputStream in Java"><img class="cover" src="https://pic.imgdb.cn/item/616863312ab3f51d9106e681.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-26</div><div class="title">Difference between FileReader vs FileInputStream in Java</div></div></a></div><div><a href="/posts/65533/" title="Java 中 IO 操作总结"><img class="cover" src="https://img.imgdb.cn/item/604b7e335aedab222ce6192e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-06</div><div class="title">Java 中 IO 操作总结</div></div></a></div><div><a href="/posts/53319/" title="Java中使用HSSFWorkbook生成excel"><img class="cover" src="https://pic.imgdb.cn/item/612111984907e2d39c4793a9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-12</div><div class="title">Java中使用HSSFWorkbook生成excel</div></div></a></div><div><a href="/posts/62287/" title="Java代码实现裁剪图像"><img class="cover" src="https://pic.imgdb.cn/item/61503a642ab3f51d91207331.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-26</div><div class="title">Java代码实现裁剪图像</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/6159d89b2ab3f51d91b0e8d0.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lorem Moon</div><div class="author-info__description">即已成过往，便随它而去吧。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">60</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">46</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hello-github-ui" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:util.you.come@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA-Socket"><span class="toc-number">1.1.</span> <span class="toc-text">JAVA Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84Socket-API"><span class="toc-number">1.2.</span> <span class="toc-text">重要的Socket API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">TCP编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">客户端实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">服务器端实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">3.</span> <span class="toc-text">说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%91%8A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B7%B2%E7%BB%8F%E5%8F%91%E9%80%81%E5%AE%8C%E4%BF%A1%E6%81%AF"><span class="toc-number">3.1.</span> <span class="toc-text">如何告知服务端已经发送完信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%80%9A%E8%BF%87Socket%E5%85%B3%E9%97%AD"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、通过Socket关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%80%9A%E8%BF%87Socket%E5%85%B3%E9%97%AD%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、通过Socket关闭输出流的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%80%9A%E8%BF%87%E7%BA%A6%E5%AE%9A%E7%AC%A6%E5%8F%B7"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、通过约定符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%80%9A%E8%BF%87%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6"><span class="toc-number">3.1.4.</span> <span class="toc-text">4、通过指定长度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4723/" title="Redis主从搭建"><img src="https://pic.imgdb.cn/item/61210fda4907e2d39c439d0c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis主从搭建"/></a><div class="content"><a class="title" href="/posts/4723/" title="Redis主从搭建">Redis主从搭建</a><time datetime="2022-10-22T06:47:40.080Z" title="Created 2022-10-22 14:47:40">2022-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43818/" title="Win10开启上帝模式"><img src="https://pic.imgdb.cn/item/621ddc1c2ab3f51d914c66cb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Win10开启上帝模式"/></a><div class="content"><a class="title" href="/posts/43818/" title="Win10开启上帝模式">Win10开启上帝模式</a><time datetime="2022-03-08T12:24:42.000Z" title="Created 2022-03-08 20:24:42">2022-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55966/" title="Ubuntu修改静态IP"><img src="https://pic.imgdb.cn/item/621ddc1c2ab3f51d914c66cb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu修改静态IP"/></a><div class="content"><a class="title" href="/posts/55966/" title="Ubuntu修改静态IP">Ubuntu修改静态IP</a><time datetime="2022-03-04T16:11:25.000Z" title="Created 2022-03-05 00:11:25">2022-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42154/" title="Java封装同步锁"><img src="https://pic.imgdb.cn/item/621ddc1c2ab3f51d914c66cb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java封装同步锁"/></a><div class="content"><a class="title" href="/posts/42154/" title="Java封装同步锁">Java封装同步锁</a><time datetime="2022-03-02T12:50:01.000Z" title="Created 2022-03-02 20:50:01">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1553/" title="初识大数据(一)"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="初识大数据(一)"/></a><div class="content"><a class="title" href="/posts/1553/" title="初识大数据(一)">初识大数据(一)</a><time datetime="2022-03-01T07:53:43.000Z" title="Created 2022-03-01 15:53:43">2022-03-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic.imgdb.cn/item/618930862ab3f51d91b34c10.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2022 By Lorem Moon</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://hello-blogger-ui.blogspot.com/">google blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'mFM6i90bN6KqyTH6tmC3q7dz-gzGzoHsz',
      appKey: 'T2tsKoiKjMaB0wgtIAgSz6Ul',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>